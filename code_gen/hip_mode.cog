#include <atomic>
#include <hip/hip_runtime.h>
#include <hip/hiprtc.h>
#include <hip/std/atomic>
#define HIP_CODE 1

class atomic_bool_gpu
{
  private:
    int value;

  public:
    __host__ __device__ atomic_bool_gpu() : value(0) {}

    __host__ __device__ atomic_bool_gpu(bool initial_value)
        : value(initial_value ? 1 : 0)
    {
    }

#if defined(__HIP_DEVICE_COMPILE__)
    // Device implementation
    __device__ void store(bool new_value)
    {
        atomicExch(&value, new_value ? 1 : 0);
    }

    __device__ bool load() const
    {
        return atomicAdd(const_cast<int*>(&value), 0) != 0;
    }

    __device__ bool exchange(bool new_value)
    {
        return atomicExch(&value, new_value ? 1 : 0) != 0;
    }

    __device__ bool compare_exchange(bool expected, bool desired)
    {
        int expected_int = expected ? 1 : 0;
        int desired_int  = desired ? 1 : 0;
        return atomicCAS(&value, expected_int, desired_int) == expected_int;
    }
#else
    // Host implementation
    __host__ void store(bool new_value)
    {
        std::atomic<int>* atomic_value =
            reinterpret_cast<std::atomic<int>*>(&value);
        atomic_value->store(new_value ? 1 : 0, std::memory_order_relaxed);
    }

    __host__ bool load() const
    {
        const std::atomic<int>* atomic_value =
            reinterpret_cast<const std::atomic<int>*>(&value);
        return atomic_value->load(std::memory_order_relaxed) != 0;
    }

    __host__ bool exchange(bool new_value)
    {
        std::atomic<int>* atomic_value =
            reinterpret_cast<std::atomic<int>*>(&value);
        return atomic_value->exchange(
                   new_value ? 1 : 0,
                   std::memory_order_relaxed
               ) != 0;
    }

    __host__ bool compare_exchange(bool expected, bool desired)
    {
        std::atomic<int>* atomic_value =
            reinterpret_cast<std::atomic<int>*>(&value);
        int expected_int = expected ? 1 : 0;
        return atomic_value->compare_exchange_strong(
            expected_int,
            desired ? 1 : 0,
            std::memory_order_relaxed
        );
    }
#endif

    // Explicit conversion operator to bool
    __host__ __device__ explicit operator bool() const
    {
#if defined(__HIP_DEVICE_COMPILE__)
        return load();
#else
        return load();
#endif
    }
};

using shared_atomic_bool = atomic_bool_gpu;
using atomic_bool        = atomic_bool_gpu;

template <typename T>
void store_atomic_bool(T& var, bool value)
{
    var.store(value);
}

#define DEV    __device__
#define KERNEL __global__
#define DUAL   __host__ __device__
#define STATIC __host__ __device__ inline
#define EXTERN extern __shared__

#if FLOAT_PRECISION
using atomic_cast = unsigned int;
#define __int_as_real __int_as_float
#define __real_as_int __float_as_int
#else
using atomic_cast = unsigned long long;
#define __int_as_real __longlong_as_double
#define __real_as_int __double_as_longlong
#endif

using sig_bool = volatile bool;
#define SINGLE(kernel_name, ...) kernel_name<<<1, 1>>>(__VA_ARGS__);

#define CALL(kernel_name, gridsize, blocksize, ...)                            \
    kernel_name<<<(gridsize), (blocksize)>>>(__VA_ARGS__);

namespace global {
#if SHARED_MEMORY
#define SHARED __device__
    // shorthand flag for using gpu shared memory
    constexpr bool on_sm = true;
#else
#define SHARED __device__ const
    // shorthand flag for using gpu shared memory
    constexpr bool on_sm = false;
#endif
    constexpr Platform BuildPlatform = Platform::GPU;
}   // namespace global

namespace global {
    constexpr int WARP_SIZE = 64;
}   // namespace global

template <typename T>
constexpr auto devMalloc(T** devPtr, size_t size)
{
    return hipMalloc(devPtr, size);
}

template <typename T>
constexpr auto devMallocManaged(T** devPtr, size_t size)
{
    return hipMallocManaged(devPtr, size);
}

inline auto devMemcpyFromSymbol(void* dst, const void* symbol, size_t count)
{
    return hipMemcpyFromSymbol(dst, symbol, count);
};

inline auto devEventCreate(hipEvent_t* stamp) { return hipEventCreate(stamp); };

inline auto devEventRecord(hipEvent_t stamp) { return hipEventRecord(stamp); };

inline auto devMallocHost(void** ptr, size_t size)
{
    return hipMallocHost(ptr, size);
};

__device__ __forceinline__ real devAtomicMinReal(real* addr, real value)
{
    real old =
        __int_as_real(atomicMin((atomic_cast*) addr, __real_as_int(value)));
    return old;
}

constexpr auto devMemcpy               = hipMemcpy;
constexpr auto devFree                 = hipFree;
constexpr auto devMemset               = hipMemset;
constexpr auto devDeviceSynchronize    = hipDeviceSynchronize;
constexpr auto devMemcpyHostToDevice   = hipMemcpyHostToDevice;
constexpr auto devMemcpyDeviceToDevice = hipMemcpyDeviceToDevice;
constexpr auto devMemcpyDeviceToHost   = hipMemcpyDeviceToHost;
constexpr auto devGetErrorString       = hipGetErrorString;
constexpr auto devEventDestroy         = hipEventDestroy;
constexpr auto devEventSynchronize     = hipEventSynchronize;
constexpr auto devEventElapsedTime     = hipEventElapsedTime;
constexpr auto devGetDeviceProperties  = hipGetDeviceProperties;
constexpr auto devGetDeviceCount       = hipGetDeviceCount;
constexpr auto devSetDevice            = hipSetDevice;
constexpr auto devStreamCreate         = hipStreamCreate;
constexpr auto devStreamDestroy        = hipStreamDestroy;
constexpr auto devStreamSynchronize    = hipStreamSynchronize;
constexpr auto devStreamWaitEvent      = hipStreamWaitEvent;
constexpr auto devStreamQuery          = hipStreamQuery;
constexpr auto devEnablePeerAccess     = hipDeviceEnablePeerAccess;
constexpr auto devGetDevice            = hipGetDevice;
constexpr auto devPeerCopyAsync        = hipMemcpyPeerAsync;
constexpr auto devMemcpyAsync          = hipMemcpyAsync;
constexpr auto devHostRegister         = hipHostRegister;
constexpr auto devHostUnregister       = hipHostUnregister;
constexpr auto devLaunchKernel         = hipLaunchKernel;

using devProp_t     = hipDeviceProp_t;
using devError_t    = hipError_t;
using devEvent_t    = hipEvent_t;
using simbiStream_t = hipStream_t;

// tools for JIT compilation
constexpr auto devCompileProgram    = hiprtcCompileProgram;
constexpr auto devCreateProgram     = hiprtcCreateProgram;
constexpr auto devGetIRSize         = hiprtcGetCodeSize;
constexpr auto devGetIR             = hiprtcGetCode;
constexpr auto devGetProgramLogSize = hiprtcGetProgramLogSize;
constexpr auto devGetProgramLog     = hiprtcGetProgramLog;
constexpr auto devLoadModule        = hipModuleLoadData;
constexpr auto devDestroyProgram    = hiprtcDestroyProgram;
constexpr auto devUnloadModule      = hipModuleUnload;
constexpr auto devGetFunction       = hipModuleGetFunction;
using devProgram_t                  = hiprtcProgram;
using devContext_t                  = hipCtx_t;
using devModule_t                   = hipModule_t;
using devDevice_t                   = hipDevice_t;
using devFunction_t                 = hipFunction_t;
