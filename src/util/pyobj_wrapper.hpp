/**
 * ***********************(C) COPYRIGHT 2024 Marcus DuPont**********************
 * @file       pyobj_wrapper.hpp
 * @brief      helper class that translates python objects to cpp objects
 *
 * @note
 * @history:
 *   Version   Date            Author          Modification    Email
 *   V0.8.0    Dec-03-2023     Marcus DuPont                   md4469@nyu.edu
 *
 * @verbatim
 * ==============================================================================
 *
 * ==============================================================================
 * @endverbatim
 * ***********************(C) COPYRIGHT 2024 Marcus DuPont**********************
 */
#ifndef PYOBJ_WRAPPER_HPP
#define PYOBJ_WRAPPER_HPP

#include "src/call_obj.pyx.h"   // cython helper file generated by cython through meson
#include <Python.h>

// Adapted from:
// https://stackoverflow.com/questions/39044063/pass-a-closure-from-cython-to-c
class PyObjWrapper
{
  public:
    // constructors and destructors mostly do reference counting
    PyObjWrapper(PyObject* o) : held(o) { Py_XINCREF(o); }

    PyObjWrapper(const PyObjWrapper& rhs) : PyObjWrapper(rhs.held)
    {   // C++11 onwards only
    }

    PyObjWrapper(PyObjWrapper&& rhs) : held(rhs.held) { rhs.held = 0; }

    // need no-arg constructor to stack allocate in Cython
    PyObjWrapper() : PyObjWrapper(nullptr) {}

    ~PyObjWrapper() { Py_XDECREF(held); }

    PyObjWrapper& operator=(const PyObjWrapper& rhs)
    {
        PyObjWrapper tmp = rhs;
        return (*this = std::move(tmp));
    }

    PyObjWrapper& operator=(PyObjWrapper&& rhs)
    {
        held     = rhs.held;
        rhs.held = 0;
        return *this;
    }

    double operator()(double t) const
    {
        if (held) {   // nullptr check
            const auto res = call_obj(held, t);
            return res;
        }
        return 0;
    }

    double operator()(double x, double t) const
    {
        if (held) {   // nullptr check
            const auto res = call_obj2(held, x, t);
            return res;
        }
        return 0;
    }

    double operator()(double x, double y, double t) const
    {
        if (held) {   // nullptr check
            const auto res = call_obj3(held, x, y, t);
            return res;
        }
        return 0;
    }

    double operator()(double x, double y, double z, double t) const
    {
        if (held) {   // nullptr check
            const auto res = call_obj4(held, x, y, z, t);
            return res;
        }
        return 0;
    }

    operator bool() const { return held; }

  private:
    PyObject* held;
};

#endif